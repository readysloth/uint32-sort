# uint32-sort
## Задание
Дан файл случайного размера, наполненный беззнаковыми, 32-бит числами (`uint32_t`). Нужно:
1. Отсортировать файл
1. Сделать обработку всевозможных ошибок
1. Добавить GUI с помощью Qt5
1. Уведомлять о прогрессе сортировки (индикатор выполнения)
1. Максимально распараллелить выполнение программы
1. Собирать проект с помощью CMake
1. Выложить проект на github

## Что сделано на текущий момент
Написана POSIX совместимая библиотека, осуществляющая сортировку `uint32_t` чисел в файле. 
Для удобства написан скрипт на Bash для генерации файлов с числами.

## Структура проекта
На данный момент заведено 3 ветки:

|   Имя ветки   |                         Предназначение                                             |
|:-------------:| ---------------------------------------------------------------------------------- |
|     aux       | Вспомогательная ветка, содержит полезные скрипты                                   |
|   dev_base    | Ветка, в которой велась разработка ядра программы                                  |
|    dev_qt     | Ветка, в которой ведется разработка GUI и связывание его с ядром программы         |
|    release    | Ветка, в которой находятся исходные файлы готовой к использованию версии программы |
|    master     | Титульная страница                                                                 |


Текущее содержание `dev_base`

```
uint32-sort/
├── CMakeLists.txt                  Правила сборки проекта
├── include                         Папка с заголовочными файлами
│   ├── file_manager.hpp	    
│   └── sort_container.hpp
├── main.cpp		            
└── src                             Папка с файлами кода
    ├── main.cpp                    Файл для проверки библиотеки
    └── sort_lib                    Папка с файлами кода библиотеки
        ├── CMakeLists.txt          Правила сборки библиотеки
        ├── file_manager.cpp
        └── sort_container.cpp

```
## Текущий результат
Для сортировки использовалась функция `qsort` из `stdlib`.
На картинке ниже показан процесс работы программы над файлом размером 64 MB
![](for_readme/uint_sort.gif)

GUI и демонстрация порядка сортировки. 

Обработка файла в 1GB занимает около 35 секунд на процессоре Intel Core i5-8250U

![](for_readme/ascSort.gif)
![](for_readme/descSort.gif)


P.S Данные изображение является не точным отображением скорости работы, а лишь демонстрируют только принцип. 
Точно отобразить изменения не позволяют задержки, связанные с обновлением `watch`, выполнением команды `od` и непосредственной интерпретации Bash'ем инструкций

## Как воспроизвести результат
1. Скомпилировать программу
1. В том же каталоге запустить скрипт из ветки `aux` -> `garbage_maker.sh -s *ваш размер* -n 2`
1. Запустить скрипт из ветки `aux` -> `watch_sort.sh *отступ в байтах от начала файла*`.\
(Например код `watch_sort.sh 4194304` будет следить за файлом начиная с границы в 4 MB)
1. Запустить скомпилированную программу

## Что использовалось при разработке помимо инструментов задания
+ Vim как редактор кода
+ GDB для отладки программы
+ Bash для автоматизации рутинных и одномоментных действий
+ Qt Creator только в качестве редактора интерфейса
